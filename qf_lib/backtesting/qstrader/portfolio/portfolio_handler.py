from qf_lib.backtesting.qstrader.events.fill_event.fill_event import FillEvent
from qf_lib.backtesting.qstrader.events.fill_event.fill_event_listener import FillEventListener
from qf_lib.backtesting.qstrader.events.fill_event.fill_event_notifier import FillEventNotifier
from qf_lib.backtesting.qstrader.events.signal_event.signal_event import SignalEvent
from qf_lib.backtesting.qstrader.events.signal_event.signal_event_listener import SignalEventListener
from qf_lib.backtesting.qstrader.events.signal_event.signal_event_notifier import SignalEventNotifier
from qf_lib.backtesting.qstrader.events.time_event.after_market_close_event import AfterMarketCloseEvent
from qf_lib.backtesting.qstrader.events.time_event.scheduler import Scheduler
from qf_lib.backtesting.qstrader.events.time_event.time_event import TimeEvent
from qf_lib.backtesting.qstrader.execution_handler.base import ExecutionHandler
from qf_lib.backtesting.qstrader.monitoring.abstract_monitor import AbstractMonitor
from qf_lib.backtesting.qstrader.portfolio.portfolio import Portfolio
from qf_lib.backtesting.qstrader.position_sizer.base import AbstractPositionSizer
from qf_lib.backtesting.qstrader.risk_manager.base import AbstractRiskManager


class PortfolioHandler(SignalEventListener, FillEventListener):
    """
    The PortfolioHandler is designed to interact with the backtesting or live trading overall event-driven
    architecture. Each PortfolioHandler contains a Portfolio object, which stores the actual Position objects.

    The PortfolioHandler takes a handle to a PositionSizer object which determines a mechanism, based on the current
    Portfolio, as to how to size a new Order.

    The PortfolioHandler also takes a handle to the RiskManager, which is used to modify any generated
    Orders to remain in line with risk parameters.
    """

    def __init__(self, execution_handler: ExecutionHandler, portfolio: Portfolio,
                 position_sizer: AbstractPositionSizer, risk_manager: AbstractRiskManager,
                 monitor: AbstractMonitor, scheduler: Scheduler,
                 fill_event_notifier: FillEventNotifier,
                 signal_event_notifier: SignalEventNotifier)-> None:
        self.execution_handler = execution_handler
        self.position_sizer = position_sizer
        self.risk_manager = risk_manager
        self.portfolio = portfolio
        self.monitor = monitor

        scheduler.subscribe(AfterMarketCloseEvent, listener=self)
        fill_event_notifier.subscribe(listener=self)
        signal_event_notifier.subscribe(listener=self)

    def on_after_market_close(self, event: TimeEvent):
        self.portfolio.update()
        self.monitor.end_of_day_update(event.time)

    def on_signal_event(self, signal_event: SignalEvent):
        """
        Awaits a signal (containing an Order) generated by a strategy. Then the Order is sized, risk adjusted
        and executed.
        """
        initial_orders = signal_event.suggested_orders
        sized_orders = self.position_sizer.size_orders(initial_orders)
        refined_orders = self.risk_manager.refine_orders(sized_orders)

        # Once the RiskManager has verified, modified or eliminated any Order objects, they are sent
        # to the ExecutionHandler.
        self.execution_handler.accept_orders(refined_orders)

    def on_fill_event(self, fill_event: FillEvent):
        """
        This is called by the backtester or live trading architecture to take a FillEvent and update the Portfolio
        object with new or modified Positions.

        In a backtesting environment these FillEvents will be simulated by a model representing the execution, whereas
        in live trading they will come directly from a brokerage (such as Interactive Brokers).
        """
        self.portfolio.transact_fill_event(fill_event)
